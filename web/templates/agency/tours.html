{% extends "agency/base.html" %}
{% block title %}Мои экскурсии{% endblock %}
{% block body %}
<div class="max-w-7xl mx-auto px-6 py-10">
  <div class="flex justify-between items-center mb-6">
    <h1 class="text-3xl font-extrabold text-cyan-700">Экскурсии</h1>
    <button id="newTourBtn" class="px-4 py-2 rounded-lg bg-cyan-600 text-white hover:bg-cyan-700">+ Новая экскурсия</button>
  </div>

  <!-- Tours table -->
  <div class="overflow-x-auto bg-white rounded-xl shadow">
    <table class="min-w-full divide-y divide-gray-200" id="toursTable">
      <thead class="bg-gray-50">
        <tr>
          <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Название</th>
          <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Билеты</th>
          <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Расписание</th>
          <th class="px-6 py-3"></th>
        </tr>
      </thead>
      <tbody class="bg-white divide-y divide-gray-200" id="toursBody"></tbody>
    </table>
  </div>
</div>

<!-- Modal for new tour -->
<div id="tourModal" class="fixed inset-0 bg-black/50 flex items-start justify-center hidden overflow-y-auto py-10">
  <div class="bg-white w-full max-w-lg rounded-xl shadow-lg p-6 my-auto max-h-[90vh] overflow-y-auto">
    <h2 class="text-xl font-semibold mb-4">Новая экскурсия</h2>
    <form id="tourForm" class="space-y-4">
      <div>
        <label class="block text-sm font-medium mb-1" for="tourTitle">Название</label>
        <input id="tourTitle" type="text" required class="w-full px-3 py-2 border rounded" />
      </div>
      <div>
        <label class="block text-sm font-medium mb-1" for="tourDesc">Описание</label>
        <textarea id="tourDesc" class="w-full px-3 py-2 border rounded"></textarea>
      </div>
      <div>
        <h3 class="font-medium mb-2">Типы билетов</h3>
        <div id="ticketRows" class="space-y-2"></div>
        <div class="flex gap-2 mt-2">
          <select id="ticketClassSel" class="flex-1 border rounded px-2 py-1 text-sm"></select>
          <input id="ticketPriceInput" type="number" step="0.01" min="0" placeholder="Цена" class="flex-1 border rounded px-2 py-1 text-sm" />
          <button type="button" id="addTicketBtn" class="px-3 py-1 bg-emerald-600 text-white rounded">Добавить</button>
        </div>
      </div>

      <div class="flex gap-4">
        <div class="flex-1">
          <label class="block text-sm font-medium mb-1" for="tourCity">Город</label>
          <select id="tourCity" class="w-full px-3 py-2 border rounded"></select>
        </div>
        <div class="flex-1">
          <label class="block text-sm font-medium mb-1">Категории</label>
          <div class="relative">
            <select id="tourCatDropdown" class="w-full px-3 py-2 border rounded">
              <option value="">Выберите категорию</option>
            </select>
            <div id="selectedCategories" class="flex flex-wrap gap-1 mt-2"></div>
            <input type="hidden" id="tourCats" name="tourCats" value="">
          </div>
          <div class="text-xs text-gray-500 mt-1">Выберите до 10 категорий</div>
        </div>
      </div>
      
      <div>
        <label class="block text-sm font-medium mb-1">Место отправления</label>
        <div class="mb-2 text-sm text-gray-600">Выберите точку на карте или воспользуйтесь поиском</div>
        <div id="map" class="h-64 w-full rounded border mb-2"></div>
        <div class="flex flex-col gap-2 bg-gray-50 p-3 rounded">
          <div class="text-sm font-medium">Адрес места сбора:</div>
          <div id="addressDisplay" class="text-gray-700">—</div>
          <input id="tourAddress" type="hidden" />
          <div class="flex gap-4 text-sm text-gray-500 mt-1">
            <div>Широта: <span id="latValue">—</span></div>
            <div>Долгота: <span id="lngValue">—</span></div>
          </div>
        </div>
      </div>

      <div>
        <label class="block text-sm font-medium mb-1" for="tourImages">Фотографии</label>
        <div id="dropArea" class="border-2 border-dashed border-gray-300 rounded-lg p-4 text-center hover:bg-gray-50 transition-colors">
          <p class="text-gray-500 mb-2">Перетащите изображения сюда или нажмите для выбора</p>
          <input id="tourImages" type="file" accept="image/*" multiple class="hidden" />
          <button type="button" id="selectImagesBtn" class="px-3 py-1 bg-cyan-600 text-white rounded">Выбрать файлы</button>
        </div>
        <div id="imagePreviewCarousel" class="mt-3 hidden">
          <h4 class="text-sm font-medium mb-2">Предпросмотр изображений:</h4>
          <div class="flex overflow-x-auto gap-2 pb-2" id="previewContainer"></div>
        </div>
      </div>

      <div class="flex justify-end gap-3 pt-4">
        <button type="button" id="cancelModal" class="px-4 py-2 rounded bg-gray-200 hover:bg-gray-300">Отмена</button>
        <button type="submit" class="px-4 py-2 rounded bg-cyan-600 text-white hover:bg-cyan-700">Создать</button>
      </div>
    </form>
  </div>
</div>

<!-- Modal for schedule configuration -->
<div id="scheduleModal" class="fixed inset-0 bg-black/50 flex items-start justify-center hidden overflow-y-auto py-10">
  <div class="bg-white w-full max-w-md rounded-xl shadow-lg p-6 my-auto max-h-[90vh] overflow-y-auto">
    <h2 class="text-xl font-semibold mb-4">Настройка расписания</h2>
    <form id="scheduleForm" class="space-y-4">
      <input type="hidden" id="scheduleTourId">
      
      <div>
        <label class="block text-sm font-medium mb-1" for="repeatType">Тип повторения</label>
        <select id="repeatType" class="w-full px-3 py-2 border rounded">
          <option value="none">Без повторения</option>
          <option value="daily">Ежедневно</option>
          <option value="weekly">Еженедельно</option>
        </select>
      </div>
      
      <div id="timeSection" class="hidden">
        <label class="block text-sm font-medium mb-1" for="repeatTime">Время</label>
        <input type="time" id="repeatTime" class="w-full px-3 py-2 border rounded" value="09:00">
        <div class="text-xs text-gray-500 mt-1">
          Время указано в вашем часовом поясе: <span id="userTimezoneDisplay">определение...</span>
        </div>
      </div>
      
      <div id="weekdaysSection" class="hidden">
        <label class="block text-sm font-medium mb-2">Дни недели</label>
        <div class="flex flex-wrap gap-2">
          <label class="inline-flex items-center px-3 py-1 bg-gray-100 rounded">
            <input type="checkbox" value="0" class="weekday-cb mr-1"> Пн
          </label>
          <label class="inline-flex items-center px-3 py-1 bg-gray-100 rounded">
            <input type="checkbox" value="1" class="weekday-cb mr-1"> Вт
          </label>
          <label class="inline-flex items-center px-3 py-1 bg-gray-100 rounded">
            <input type="checkbox" value="2" class="weekday-cb mr-1"> Ср
          </label>
          <label class="inline-flex items-center px-3 py-1 bg-gray-100 rounded">
            <input type="checkbox" value="3" class="weekday-cb mr-1"> Чт
          </label>
          <label class="inline-flex items-center px-3 py-1 bg-gray-100 rounded">
            <input type="checkbox" value="4" class="weekday-cb mr-1"> Пт
          </label>
          <label class="inline-flex items-center px-3 py-1 bg-gray-100 rounded">
            <input type="checkbox" value="5" class="weekday-cb mr-1"> Сб
          </label>
          <label class="inline-flex items-center px-3 py-1 bg-gray-100 rounded">
            <input type="checkbox" value="6" class="weekday-cb mr-1"> Вс
          </label>
        </div>
      </div>
      
      <div class="flex justify-end gap-3 pt-4">
        <button type="button" id="cancelScheduleModal" class="px-4 py-2 rounded bg-gray-200 hover:bg-gray-300">Отмена</button>
        <button type="submit" class="px-4 py-2 rounded bg-cyan-600 text-white hover:bg-cyan-700">Сохранить</button>
      </div>
      
      <!-- Hidden input for timezone -->
      <input type="hidden" id="userTimezone" name="userTimezone">
    </form>
  </div>
</div>

<!-- Modal for location view -->
<div id="locationModal" class="fixed inset-0 bg-black/50 flex items-start justify-center hidden overflow-y-auto py-10">
  <div class="bg-white w-full max-w-lg rounded-xl shadow-lg p-6 my-auto max-h-[90vh] overflow-y-auto">
    <h2 class="text-xl font-semibold mb-4">Место отправления</h2>
    <div id="addressDisplay" class="mb-4 text-gray-700"></div>
    <div id="viewMap" class="h-80 w-full rounded border mb-4"></div>
    <div class="flex justify-end gap-3">
      <button type="button" id="closeLocationModal" class="px-4 py-2 rounded bg-gray-200 hover:bg-gray-300">Закрыть</button>
    </div>
  </div>
</div>

<!-- Modal for ticket categories -->
<div id="ticketsModal" class="fixed inset-0 bg-black/50 flex items-start justify-center hidden overflow-y-auto py-10">
  <div class="bg-white w-full max-w-lg rounded-xl shadow-lg p-6 my-auto max-h-[90vh] overflow-y-auto">
    <h2 class="text-xl font-semibold mb-4">Управление билетами</h2>
    <input type="hidden" id="ticketsTourId">
    
    <div class="mb-4">
      <h3 class="text-md font-medium mb-2">Текущие типы билетов</h3>
      <div id="currentTickets" class="space-y-2 mb-4">
        <!-- Ticket rows will be inserted here -->
        <div class="text-gray-500 italic">Загрузка...</div>
      </div>
      
      <div class="border-t pt-4 mt-4">
        <h3 class="text-md font-medium mb-2">Добавить новый тип билета</h3>
        <div class="flex gap-2">
          <select id="ticketModalClassSel" class="flex-1 border rounded px-3 py-2 text-sm"></select>
          <input id="ticketModalPriceInput" type="number" step="0.01" min="0" placeholder="Цена" class="flex-1 border rounded px-3 py-2 text-sm" />
          <button type="button" id="addModalTicketBtn" class="px-4 py-2 rounded bg-emerald-600 text-white hover:bg-emerald-700">Добавить</button>
        </div>
      </div>
    </div>
    
    <div class="flex justify-end gap-3 pt-4 border-t">
      <button type="button" id="closeTicketsModal" class="px-4 py-2 rounded bg-gray-200 hover:bg-gray-300">Закрыть</button>
    </div>
  </div>
</div>

<script src="https://api-maps.yandex.ru/2.1/?apikey=538e9cdd-117d-4fae-824a-767930c27f1e&lang=ru_RU" type="text/javascript"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
  // Tour array to store data in memory
  let tourRows = [];
  let ticketRows = [];
  let selectedFiles = [];
  
  // Define weekdaysRU early before it's used
  const weekdaysRU = ['Пн','Вт','Ср','Чт','Пт','Сб','Вс'];
  
  // Format time for display with proper timezone conversion
  function fmtTime(utcTimeStr) {
    if (!utcTimeStr) return '';
    
    // Parse the UTC time (format is typically "HH:MM:SS" from API)
    const [hours, minutes] = utcTimeStr.slice(0, 5).split(':').map(Number);
    
    // Get today's date in UTC
    const now = new Date();
    const utcDate = new Date(Date.UTC(
      now.getUTCFullYear(),
      now.getUTCMonth(),
      now.getUTCDate(),
      hours,
      minutes
    ));
    
    // Convert to local time (browser's timezone)
    const localHours = utcDate.getHours();
    const localMinutes = utcDate.getMinutes();
    
    // Format as HH:MM
    return `${localHours.toString().padStart(2, '0')}:${localMinutes.toString().padStart(2, '0')}`;
  }

  function formatScheduleBadge(t) {
    // t.repeat_time comes from the server in UTC
    // Convert it to local time for display
    const timeToShow = fmtTime(t.repeat_time);
    
    if (t.repeat_type === 'daily') {
      return `<span class="inline-block px-2 bg-emerald-100 rounded hover:bg-emerald-200 transition-colors">🗓 ${timeToShow}</span>`;
    }
    if (t.repeat_type === 'weekly') {
      const days = t.repeat_weekdays.map(i => weekdaysRU[i]).join(' ');
      return `<span class="inline-block px-2 bg-amber-100 rounded hover:bg-amber-200 transition-colors">⏲ ${timeToShow} — ${days}</span>`;
    }
    return '<span class="inline-block px-2 bg-gray-100 rounded">+</span>';
  }
  
  // Various DOM elements
  const toursTable = document.getElementById('toursTable');
  const toursBody = document.getElementById('toursBody');
  const tourModal = document.getElementById('tourModal');
  const tourForm = document.getElementById('tourForm');
  const tourTitleInput = document.getElementById('tourTitle');
  const tourDescInput = document.getElementById('tourDesc');
  const tourCitySelect = document.getElementById('tourCity');
  const tourImages = document.getElementById('tourImages');
  const dropArea = document.getElementById('dropArea');
  const imagePreviewCarousel = document.getElementById('imagePreviewCarousel');
  const previewContainer = document.getElementById('previewContainer');
  const ticketClassSelect = document.getElementById('ticketClassSel');
  const ticketPriceInput = document.getElementById('ticketPriceInput');
  const ticketRowsContainer = document.getElementById('ticketRows');
  const cancelBtn = document.getElementById('cancelModal');
  const newTourBtn = document.getElementById('newTourBtn');
  
  // Helper function to get browser timezone with fallback to offset format
  function getBrowserTimezone() {
    try {
      // Try to get the IANA timezone name (e.g., "Europe/Moscow")
      const timezone = Intl.DateTimeFormat().resolvedOptions().timezone;
      
      // If timezone is "UTC" but we actually have a non-zero offset, use offset-based format instead
      if (timezone === "UTC") {
        const date = new Date();
        const offset = -date.getTimezoneOffset();
        
        // If offset is 0, it really is UTC
        if (offset === 0) {
          return "UTC";
        }
        
        // Otherwise, create a timezone string with the offset
        const offsetHours = Math.abs(Math.floor(offset / 60));
        const offsetMinutes = Math.abs(offset % 60);
        const offsetSign = offset >= 0 ? "+" : "-";
        return `UTC${offsetSign}${offsetHours.toString().padStart(2, '0')}:${offsetMinutes.toString().padStart(2, '0')}`;
      }
      
      return timezone || getTimezoneOffset(); // Fall back to offset format if null
    } catch (e) {
      console.error("Error detecting browser timezone:", e);
      return getTimezoneOffset(); // Fall back to offset format
    }
  }

  // Get timezone as offset format (UTC+XX:XX)
  function getTimezoneOffset() {
    try {
      const date = new Date();
      const offset = -date.getTimezoneOffset();
      const offsetHours = Math.abs(Math.floor(offset / 60));
      const offsetMinutes = Math.abs(offset % 60);
      const offsetSign = offset >= 0 ? "+" : "-";
      return `UTC${offsetSign}${offsetHours.toString().padStart(2, '0')}:${offsetMinutes.toString().padStart(2, '0')}`;
    } catch (e) {
      console.error("Error calculating timezone offset:", e);
      return "UTC";
    }
  }

  // Helper function to format timezone for display
  function formatTimezoneForDisplay(timezone) {
    try {
      // If it's already an offset-based timezone (like UTC+03:00), just return it
      if (timezone.startsWith('UTC+') || timezone.startsWith('UTC-')) {
        return timezone;
      }
      
      // If it's a named timezone (like Europe/Moscow), append the offset
      const date = new Date();
      const offset = -date.getTimezoneOffset();
      const offsetHours = Math.abs(Math.floor(offset / 60));
      const offsetMinutes = Math.abs(offset % 60);
      const offsetSign = offset >= 0 ? "+" : "-";
      const formattedOffset = `${offsetSign}${offsetHours.toString().padStart(2, '0')}:${offsetMinutes.toString().padStart(2, '0')}`;
      
      return `${timezone} (UTC${formattedOffset})`;
    } catch (e) {
      console.error("Error formatting timezone:", e);
      return timezone;
    }
  }

  // Function to load cities
  async function loadCities() {
    try {
      const cities = await fetch('/api/v1/public/cities').then(r => r.json()).catch(() => []);
      const citySel = document.getElementById('tourCity');
      citySel.innerHTML = '<option value="">—</option>' + 
        cities.map(c => `<option value="${c.id}">${c.name}</option>`).join('');
    } catch (err) {
      console.error('Error loading cities:', err);
    }
  }

  // Function to load ticket classes
  async function loadTicketClasses() {
    try {
      const tClass = await fetch('/api/v1/public/ticket_classes').then(r => r.json()).catch(() => []);
      const clsSel = document.getElementById('ticketClassSel');
      clsSel.innerHTML = '<option value="">Тип</option>' + 
        tClass.map(c => `<option value="${c.id}">${c.name}</option>`).join('');
    } catch (err) {
      console.error('Error loading ticket classes:', err);
    }
  }
  
  // Function to load tours from API
  async function loadTours() {
    try {
      const res = await fetch('/api/v1/agency/tours/list');
      if (!res.ok) throw new Error('Failed to load tours');
      
      tourRows = await res.json();
      renderTours();
    } catch (err) {
      console.error('Error loading tours:', err);
      toursBody.innerHTML = `<tr><td colspan="5" class="px-6 py-4 text-center text-red-500">Ошибка загрузки экскурсий</td></tr>`;
    }
  }
  
  // Function to render tours in the table
  function renderTours() {
    if (!tourRows || tourRows.length === 0) {
      toursBody.innerHTML = `<tr><td colspan="5" class="px-6 py-4 text-center text-gray-500">Экскурсий пока нет</td></tr>`;
      return;
    }
    
    toursBody.innerHTML = tourRows.map(tour => `
      <tr>
        <td class="px-6 py-4">${tour.title}</td>
        <td class="px-6 py-4">
          <button data-id="${tour.id}" class="ticketsBtn px-2 py-1 text-xs rounded bg-blue-100 hover:bg-blue-200">Управление</button>
        </td>
        <td class="px-6 py-4">
          <button data-id="${tour.id}" class="scheduleBtn">${formatScheduleBadge(tour)}</button>
        </td>
        <td class="px-6 py-4 text-right">
          <div class="flex justify-end space-x-2">
            <button data-id="${tour.id}" class="editTourBtn p-1 text-amber-600 hover:text-amber-800">✎</button>
            <button data-id="${tour.id}" class="deleteTourBtn p-1 text-red-600 hover:text-red-800">×</button>
          </div>
        </td>
      </tr>
    `).join('');
    
    // Add event listeners to buttons
    toursBody.querySelectorAll('.scheduleBtn').forEach(btn => {
      btn.addEventListener('click', () => {
        const tour = tourRows.find(t => t.id === parseInt(btn.getAttribute('data-id')));
        openRecModal(tour);
      });
    });
    
    toursBody.querySelectorAll('.ticketsBtn').forEach(btn => {
      btn.addEventListener('click', () => {
        openTicketsModal(parseInt(btn.getAttribute('data-id')));
      });
    });
    
    // Edit and delete buttons
    toursBody.querySelectorAll('.editTourBtn').forEach(btn => {
      btn.addEventListener('click', async () => {
        // Load tour details and open edit modal
        const tourId = parseInt(btn.getAttribute('data-id'));
        // ... (edit implementation)
      });
    });
    
    toursBody.querySelectorAll('.deleteTourBtn').forEach(btn => {
      btn.addEventListener('click', async () => {
        if (!confirm('Вы уверены, что хотите удалить эту экскурсию?')) return;
        
        const tourId = parseInt(btn.getAttribute('data-id'));
        try {
          const res = await fetch(`/api/v1/agency/tours/${tourId}`, {method: 'DELETE'});
          if (!res.ok) throw new Error('Failed to delete tour');
          
          // Reload tours
          loadTours();
        } catch (err) {
          console.error('Error deleting tour:', err);
          alert('Ошибка при удалении экскурсии');
        }
      });
    });
  }
  
  // Now that all functions are defined, load the data
  loadTours();
  loadCities();
  loadTicketClasses();
  
  // Handle drag and drop image functionality
  // Use the already declared variables instead of redeclaring them
  // const dropArea = document.getElementById('dropArea');
  // const imageInput = document.getElementById('tourImages');
  // const selectImagesBtn = document.getElementById('selectImagesBtn');
  // const imagePreviewCarousel = document.getElementById('imagePreviewCarousel');
  // const previewContainer = document.getElementById('previewContainer');
  // const selectedFiles = [];

  // Open file dialog when button is clicked
  const selectImagesBtn = document.getElementById('selectImagesBtn');
  const imageInput = document.getElementById('tourImages');

  selectImagesBtn.addEventListener('click', () => {
    imageInput.click();
  });

  // Handle file selection
  imageInput.addEventListener('change', handleFileSelect);

  // Drag and drop events
  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
    dropArea.addEventListener(eventName, preventDefaults, false);
  });

  function preventDefaults(e) {
    e.preventDefault();
    e.stopPropagation();
  }

  ['dragenter', 'dragover'].forEach(eventName => {
    dropArea.addEventListener(eventName, highlight, false);
  });

  ['dragleave', 'drop'].forEach(eventName => {
    dropArea.addEventListener(eventName, unhighlight, false);
  });

  function highlight() {
    dropArea.classList.add('border-cyan-500', 'bg-cyan-50');
  }

  function unhighlight() {
    dropArea.classList.remove('border-cyan-500', 'bg-cyan-50');
  }

  // Handle the dropped files
  dropArea.addEventListener('drop', handleDrop, false);

  function handleDrop(e) {
    const dt = e.dataTransfer;
    const files = dt.files;
    handleFiles(files);
  }

  function handleFileSelect(e) {
    const files = e.target.files;
    handleFiles(files);
  }

  function handleFiles(files) {
    if (files.length === 0) return;
    
    // Clear previous previews if needed
    if (selectedFiles.length === 0) {
      previewContainer.innerHTML = '';
    }
    
    // Process each file
    Array.from(files).forEach(file => {
      if (!file.type.match('image.*')) return;
      
      selectedFiles.push(file);
      
      const reader = new FileReader();
      reader.onload = function(e) {
        const div = document.createElement('div');
        div.className = 'relative flex-shrink-0';
        div.innerHTML = `
          <img src="${e.target.result}" class="h-24 w-auto rounded border border-gray-300" />
          <button type="button" class="absolute top-0 right-0 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center remove-image">×</button>
        `;
        previewContainer.appendChild(div);
        
        // Add remove functionality
        div.querySelector('.remove-image').addEventListener('click', function() {
          const index = Array.from(previewContainer.children).indexOf(div);
          selectedFiles.splice(index, 1);
          div.remove();
          
          // Hide carousel if no images
          if (selectedFiles.length === 0) {
            imagePreviewCarousel.classList.add('hidden');
          }
        });
        
        // Show the preview carousel
        imagePreviewCarousel.classList.remove('hidden');
      };
      reader.readAsDataURL(file);
    });
  }

  // Initialize Yandex Map
  let myMap, myPlacemark;
  let mapInitialized = false;
  
  function initMap() {
    if (mapInitialized) return;
    
    ymaps.ready(() => {
      // Default center (Moscow)
      const defaultCenter = [55.76, 37.64];
      
      myMap = new ymaps.Map('map', {
        center: defaultCenter,
        zoom: 12,
        controls: ['zoomControl', 'searchControl']
      });
      
      // Create a placemark
      myPlacemark = new ymaps.Placemark(defaultCenter, {
        hintContent: 'Место отправления'
      }, {
        draggable: true
      });
      
      // Add placemark to map
      myMap.geoObjects.add(myPlacemark);
      
      // Update coordinates when placemark is dragged
      myPlacemark.events.add('dragend', function() {
        const coords = myPlacemark.geometry.getCoordinates();
        updateCoordinates(coords[0], coords[1]);
        reverseGeocode(coords);
      });
      
      // Click on map to move placemark
      myMap.events.add('click', function(e) {
        const coords = e.get('coords');
        myPlacemark.geometry.setCoordinates(coords);
        updateCoordinates(coords[0], coords[1]);
        reverseGeocode(coords);
      });
      
      // Search control events
      const searchControl = myMap.controls.get('searchControl');
      searchControl.events.add('resultselect', function(e) {
        const results = searchControl.getResultsArray();
        const selected = results[e.get('index')];
        const coords = selected.geometry.getCoordinates();
        
        myPlacemark.geometry.setCoordinates(coords);
        updateCoordinates(coords[0], coords[1]);
        
        // Get full address from search result
        const address = selected.properties.get('text');
        document.getElementById('tourAddress').value = address;
        document.getElementById('addressDisplay').textContent = address;
      });
      
      mapInitialized = true;
    });
  }
  
  // Update coordinate display
  function updateCoordinates(lat, lng) {
    document.getElementById('latValue').textContent = lat.toFixed(6);
    document.getElementById('lngValue').textContent = lng.toFixed(6);
  }
  
  // Reverse geocode to get address from coordinates
  function reverseGeocode(coords) {
    ymaps.geocode(coords).then(function(res) {
      const firstGeoObject = res.geoObjects.get(0);
      if (firstGeoObject) {
        // Get full address
        const address = firstGeoObject.getAddressLine();
        
        // Update hidden input and display
        document.getElementById('tourAddress').value = address;
        document.getElementById('addressDisplay').textContent = address;
      }
    });
  }
  
  // Initialize map when modal is opened
  newTourBtn.addEventListener('click', function() {
    setTimeout(initMap, 100); // Small delay to ensure DOM is ready
  });
  
  // Schedule modal
  const scheduleModal = document.getElementById('scheduleModal');
  const scheduleForm = document.getElementById('scheduleForm');
  const repeatTypeSelect = document.getElementById('repeatType');
  const timeSection = document.getElementById('timeSection');
  const weekdaysSection = document.getElementById('weekdaysSection');
  const scheduleTourIdInput = document.getElementById('scheduleTourId');
  const repeatTimeInput = document.getElementById('repeatTime');
  const weekdayCbs = document.querySelectorAll('.weekday-cb');
  const cancelScheduleBtn = document.getElementById('cancelScheduleModal');
  
  // Tickets modal
  const ticketsModal = document.getElementById('ticketsModal');
  const ticketsTourIdInput = document.getElementById('ticketsTourId');
  const currentTicketsContainer = document.getElementById('currentTickets');
  const ticketModalClassSel = document.getElementById('ticketModalClassSel');
  const ticketModalPriceInput = document.getElementById('ticketModalPriceInput');
  const addModalTicketBtn = document.getElementById('addModalTicketBtn');
  const closeTicketsModal = document.getElementById('closeTicketsModal');

  // Show/hide sections based on repeat type
  repeatTypeSelect.addEventListener('change', () => {
    const type = repeatTypeSelect.value;
    timeSection.classList.toggle('hidden', type === 'none');
    weekdaysSection.classList.toggle('hidden', type !== 'weekly');
  });

  // Load repetition types
  async function loadRepetitionTypes() {
    try {
      const res = await fetch('/api/v1/public/repetition_types');
      if (!res.ok) throw new Error('Failed to load repetition types');
      
      const types = await res.json();
      repeatTypeSelect.innerHTML = types.map(t => 
        `<option value="${t.code}">${t.name}</option>`
      ).join('');
    } catch (err) {
      console.error('Error loading repetition types:', err);
      // Fallback to hardcoded values
      repeatTypeSelect.innerHTML = `
        <option value="none">Без повторения</option>
        <option value="daily">Ежедневно</option>
        <option value="weekly">Еженедельно</option>
      `;
    }
  }

  // Get the timezone offset string in standard format (UTC±XX:XX)
  function getTimezoneString() {
    const offset = -new Date().getTimezoneOffset(); // minutes (note: getTimezoneOffset returns opposite sign)
    const sign = offset >= 0 ? '+' : '-';
    const absOffset = Math.abs(offset);
    const hours = Math.floor(absOffset / 60).toString().padStart(2, '0');
    const minutes = (absOffset % 60).toString().padStart(2, '0');
    return `UTC${sign}${hours}:${minutes}`;
  }

  // Helper function for timezone handling - always returns the offset format
  function getTimezone() {
    return getTimezoneString();
  }

  // Open schedule modal
  async function openRecModal(tour) {
    // Load repetition types if not already loaded
    if (repeatTypeSelect.children.length === 0) {
      await loadRepetitionTypes();
    }
    
    scheduleTourIdInput.value = tour.id;
    
    // Set initial values
    repeatTypeSelect.value = tour.repeat_type || 'none';
    
    // Set time if exists - convert from UTC to local time for editing
    if (tour.repeat_time) {
      const localTime = fmtTime(tour.repeat_time);
      repeatTimeInput.value = localTime;
    } else {
      repeatTimeInput.value = '09:00';
    }
    
    // Set weekdays if exists
    weekdayCbs.forEach(cb => cb.checked = false);
    if (tour.repeat_weekdays && Array.isArray(tour.repeat_weekdays)) {
      tour.repeat_weekdays.forEach(day => {
        const cb = document.querySelector(`.weekday-cb[value="${day}"]`);
        if (cb) cb.checked = true;
      });
    }
    
    // Show/hide sections based on type
    timeSection.classList.toggle('hidden', repeatTypeSelect.value === 'none');
    weekdaysSection.classList.toggle('hidden', repeatTypeSelect.value !== 'weekly');
    
    // Display the timezone info
    const timezone = getTimezone();
    document.getElementById('userTimezoneDisplay').textContent = timezone;
    document.getElementById('userTimezone').value = timezone;
    
    // Show modal
    scheduleModal.classList.remove('hidden');
  }
  
  // Open tickets modal
  async function openTicketsModal(tourId) {
    ticketsTourIdInput.value = tourId;
    
    // Load ticket classes if not already loaded
    if (ticketModalClassSel.children.length === 0) {
      const tClass = await fetch('/api/v1/public/ticket_classes').then(r=>r.json()).catch(()=>[]);
      ticketModalClassSel.innerHTML = '<option value="">Выберите тип</option>' + 
        tClass.map(c=>`<option value="${c.id}">${c.name}</option>`).join('');
    }
    
    // Load current ticket categories
    await loadTicketCategories(tourId);
    
    // Show modal
    ticketsModal.classList.remove('hidden');
  }
  
  // Load ticket categories for a tour
  async function loadTicketCategories(tourId) {
    try {
      currentTicketsContainer.innerHTML = '<div class="text-gray-500 italic">Загрузка...</div>';
      
      const res = await fetch(`/api/v1/agency/tours/${tourId}/categories`);
      if (!res.ok) throw new Error('Failed to load ticket categories');
      
      const categories = await res.json();
      
      if (categories.length === 0) {
        currentTicketsContainer.innerHTML = '<div class="text-gray-500 italic">Нет типов билетов</div>';
        return;
      }
      
      // Render ticket categories
      currentTicketsContainer.innerHTML = categories.map(cat => `
        <div class="flex justify-between items-center bg-gray-50 px-3 py-2 rounded">
          <span>${cat.name}</span>
          <div class="flex items-center gap-2">
            <span class="font-medium">${cat.price}</span>
            <button type="button" data-id="${cat.id}" data-tour-id="${tourId}" class="editTicket px-2 rounded bg-amber-200 hover:bg-amber-300">✎</button>
            <button type="button" data-id="${cat.id}" data-tour-id="${tourId}" class="deleteTicket px-2 rounded bg-red-200 hover:bg-red-300">×</button>
          </div>
        </div>
      `).join('');
      
      // Add event listeners
      currentTicketsContainer.querySelectorAll('.editTicket').forEach(btn => {
        btn.addEventListener('click', editTicketCategory);
      });
      
      currentTicketsContainer.querySelectorAll('.deleteTicket').forEach(btn => {
        btn.addEventListener('click', deleteTicketCategory);
      });
      
    } catch (err) {
      console.error('Error loading ticket categories:', err);
      currentTicketsContainer.innerHTML = '<div class="text-red-500">Ошибка загрузки типов билетов</div>';
    }
  }
  
  // Edit ticket category
  async function editTicketCategory(e) {
    const catId = e.target.getAttribute('data-id');
    const tourId = e.target.getAttribute('data-tour-id');
    const newPrice = prompt('Введите новую цену:');
    
    if (!newPrice || isNaN(newPrice) || parseFloat(newPrice) <= 0) {
      alert('Пожалуйста, введите корректную цену');
      return;
    }
    
    try {
      const res = await fetch(`/api/v1/agency/tours/${tourId}/categories/${catId}`, {
        method: 'PATCH',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          ticket_class_id: 0, // Not used for update, but required by schema
          price: parseFloat(newPrice)
        })
      });
      
      if (!res.ok) throw new Error('Failed to update ticket category');
      
      // Reload ticket categories
      await loadTicketCategories(tourId);
      
    } catch (err) {
      console.error('Error updating ticket category:', err);
      alert('Ошибка при обновлении типа билета');
    }
  }
  
  // Delete ticket category
  async function deleteTicketCategory(e) {
    const catId = e.target.getAttribute('data-id');
    const tourId = e.target.getAttribute('data-tour-id');
    
    if (!confirm('Вы уверены, что хотите удалить этот тип билета?')) {
      return;
    }
    
    try {
      const res = await fetch(`/api/v1/agency/tours/${tourId}/categories/${catId}`, {
        method: 'DELETE'
      });
      
      if (!res.ok) {
        if (res.status === 400) {
          alert('Нельзя удалить стандартный тип билета. Экскурсия должна иметь хотя бы один тип билета.');
        } else {
          throw new Error('Failed to delete ticket category');
        }
      }
      
      // Reload ticket categories
      await loadTicketCategories(tourId);
      
    } catch (err) {
      console.error('Error deleting ticket category:', err);
      alert('Ошибка при удалении типа билета');
    }
  }
  
  // Close schedule modal
  cancelScheduleBtn.addEventListener('click', () => {
    scheduleModal.classList.add('hidden');
  });
  
  // Close tickets modal
  closeTicketsModal.addEventListener('click', () => {
    ticketsModal.classList.add('hidden');
  });
  
  // Location modal
  const locationModal = document.getElementById('locationModal');
  const closeLocationModal = document.getElementById('closeLocationModal');
  let viewMap;
  
  function openLocationModal(lat, lng, address) {
    // Display address
    document.getElementById('addressDisplay').textContent = address || 'Адрес не указан';
    
    // Show modal
    locationModal.classList.remove('hidden');
    
    // Initialize map
    setTimeout(() => {
      ymaps.ready(() => {
        // Default center if no coordinates
        const center = (lat && lng) ? [parseFloat(lat), parseFloat(lng)] : [55.76, 37.64];
        
        viewMap = new ymaps.Map('viewMap', {
          center: center,
          zoom: 15,
          controls: ['zoomControl']
        });
        
        if (lat && lng) {
          // Add placemark
          const placemark = new ymaps.Placemark([parseFloat(lat), parseFloat(lng)], {
            hintContent: address || 'Место отправления'
          });
          
          viewMap.geoObjects.add(placemark);
        }
      });
    }, 100);
  }
  
  // Close location modal
  closeLocationModal.addEventListener('click', () => {
    locationModal.classList.add('hidden');
    // Destroy map to prevent memory leaks
    if (viewMap) {
      viewMap.destroy();
      viewMap = null;
    }
  });
  
  // Add ticket category from modal
  addModalTicketBtn.addEventListener('click', async () => {
    const tourId = ticketsTourIdInput.value;
    const ticketClassId = ticketModalClassSel.value;
    const price = ticketModalPriceInput.value;
    
    if (!ticketClassId || !price || isNaN(price) || parseFloat(price) <= 0) {
      alert('Пожалуйста, выберите тип билета и введите корректную цену');
      return;
    }
    
    try {
      const res = await fetch(`/api/v1/agency/tours/${tourId}/categories`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          ticket_class_id: parseInt(ticketClassId),
          price: parseFloat(price)
        })
      });
      
      if (!res.ok) throw new Error('Failed to add ticket category');
      
      // Reset form
      ticketModalClassSel.value = '';
      ticketModalPriceInput.value = '';
      
      // Reload ticket categories
      await loadTicketCategories(tourId);
      
    } catch (err) {
      console.error('Error adding ticket category:', err);
      alert('Ошибка при добавлении типа билета');
    }
  });
  
  // Submit schedule form
  scheduleForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const tourId = scheduleTourIdInput.value;
    const type = repeatTypeSelect.value;
    const time = type !== 'none' ? repeatTimeInput.value : null;
    
    // Get selected weekdays
    let weekdays = null;
    if (type === 'weekly') {
      weekdays = Array.from(weekdayCbs)
        .filter(cb => cb.checked)
        .map(cb => parseInt(cb.value));
    }
    
    // Use timezone offset directly
    const timezone = getTimezone();
    console.log("Using timezone:", timezone);
    
    try {
      // Create the payload
      const payload = {
        repeat_type: type,
        repeat_weekdays: weekdays,
        repeat_time: time,
        timezone: timezone
      };
      
      console.log("Sending payload:", payload);
      
      const res = await fetch(`/api/v1/agency/tours/${tourId}`, {
        method: 'PATCH',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(payload)
      });
      
      if (!res.ok) {
        const errorText = await res.text();
        throw new Error(`Failed to update schedule: ${errorText}`);
      }
      
      scheduleModal.classList.add('hidden');
      loadTours();
    } catch (err) {
      console.error("Schedule update error:", err);
      alert('Error: ' + err.message);
    }
  });

  // Handle category selection
  const categoryDropdown = document.getElementById('tourCatDropdown');
  const selectedCategories = document.getElementById('selectedCategories');
  const hiddenCategoriesInput = document.getElementById('tourCats');
  const selectedCategoryIds = new Set();
  
  // Store all categories for reference
  let allCategories = [];
  
  async function loadCategories() {
    try {
      allCategories = await fetch('/api/v1/public/tour_categories').then(r => r.json());
      updateCategoryDropdown();
    } catch (err) {
      console.error('Failed to load categories:', err);
      allCategories = [];
    }
  }
  
  function updateCategoryDropdown() {
    const dropdown = document.getElementById('tourCatDropdown');
    dropdown.innerHTML = '<option value="">Выберите категорию</option>';
    
    // Only show categories that haven't been selected yet
    allCategories.forEach(cat => {
      if (!selectedCategoryIds.has(cat.id.toString())) {
        dropdown.innerHTML += `<option value="${cat.id}">${cat.name}</option>`;
      }
    });
  }
  
  function addCategoryBadge(id, name) {
    if (selectedCategoryIds.size >= 10) {
      alert('Максимальное количество категорий: 10');
      return false;
    }
    
    const badge = document.createElement('div');
    badge.className = 'bg-blue-100 text-blue-800 px-2 py-1 rounded-full text-sm flex items-center';
    badge.dataset.id = id;
    badge.innerHTML = `
      ${name}
      <button type="button" class="ml-1 text-blue-500 hover:text-blue-700 font-bold remove-category">×</button>
    `;
    
    badge.querySelector('.remove-category').addEventListener('click', () => {
      removeCategory(id);
    });
    
    selectedCategories.appendChild(badge);
    selectedCategoryIds.add(id.toString());
    updateHiddenInput();
    updateCategoryDropdown();
    return true;
  }
  
  function removeCategory(id) {
    const badge = selectedCategories.querySelector(`[data-id="${id}"]`);
    if (badge) {
      badge.remove();
      selectedCategoryIds.delete(id.toString());
      updateHiddenInput();
      updateCategoryDropdown();
    }
  }
  
  function updateHiddenInput() {
    hiddenCategoriesInput.value = Array.from(selectedCategoryIds).join(',');
  }
  
  categoryDropdown.addEventListener('change', (e) => {
    const selectedId = e.target.value;
    if (!selectedId) return;
    
    const selectedOption = e.target.options[e.target.selectedIndex];
    const categoryName = selectedOption.textContent;
    
    if (addCategoryBadge(selectedId, categoryName)) {
      // Reset dropdown
      e.target.value = '';
    }
  });
  
  // Initialize categories
  loadCategories();

  // Function to load categories for a specific tour
  async function loadTourCategories(tourId) {
    try {
      // Clear existing categories
      resetCategorySelection();
      
      // Get tour details
      const tourRes = await fetch(`/api/v1/agency/tours/${tourId}`);
      if (!tourRes.ok) throw new Error('Failed to load tour');
      
      const tour = await tourRes.json();
      
      // Add categories if available
      if (tour.category_ids && tour.category_ids.length > 0) {
        // Make sure allCategories is loaded
        if (allCategories.length === 0) {
          await loadCategories();
        }
        
        // Add each category
        for (let i = 0; i < tour.category_ids.length; i++) {
          const catId = tour.category_ids[i];
          const category = allCategories.find(c => c.id === catId);
          if (category) {
            addCategoryBadge(catId.toString(), category.name);
          }
        }
      } else if (tour.category_id) {
        // Legacy: add single category if available
        const category = allCategories.find(c => c.id === tour.category_id);
        if (category) {
          addCategoryBadge(tour.category_id.toString(), category.name);
        }
      }
    } catch (err) {
      console.error('Error loading tour categories:', err);
    }
  }
});
</script>
{% endblock %} 