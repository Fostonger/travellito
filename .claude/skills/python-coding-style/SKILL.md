---
name: python-coding-style
description: Правила написания кода в этом репозитории (FastAPI + aiogram + SQLAlchemy + Alembic + Minio). Используй при добавлении фич, исправлении багов, рефакторинге, создании новых модулей, эндпоинтов, хендлеров бота, репозиториев, миграций.
---

# Python coding style

## Общие принципы

- Пиши изменения минимальными и локальными.  
  Не смешивай рефакторинг и фичу в одном PR без необходимости.
- Сначала структура и контракты (схемы, интерфейсы, DTO), потом реализация.
- Типизация обязательна:
  - в публичных функциях и методах,
  - в сервисном слое,
  - в контрактах между слоями.
- Явные контракты важнее неявных соглашений.
- Избегай «умного» кода — предпочитай читаемый и предсказуемый.
- Ошибки:
  - доменные исключения генерируются внутри application/domain,
  - маппинг в HTTP/telegram-ответы делается только на boundary-уровне.
- Логи:
  - структурированные,
  - без секретов,
  - с контекстом: request_id, user_id, booking_id и т.п.

---

# Архитектура и дизайн

## Clean Architecture

- Код должен быть организован по слоям с явными границами:
  - **transport / boundary** – FastAPI routers, aiogram handlers  
  - **application / service** – бизнес-логика  
  - **infrastructure** – БД, Minio, внешние клиенты  
  - **domain** – сущности, правила, доменные исключения

- Зависимости направлены только внутрь:

transport → application → domain → infrastructure (через интерфейсы)

- Внешние технологии (DB, HTTP-клиенты, Minio) НЕ должны протекать в application-слой.

- Application-слой работает только с:
- интерфейсами,
- DTO,
- доменными моделями.

- Infrastructure зависит от application, а не наоборот.

---

## SOLID в повседневной разработке

### S — Single Responsibility

- Класс/модуль должен иметь одну зону ответственности.
- Не смешивай:
- бизнес-логику,
- доступ к БД,
- работу с сетью,
- форматирование ответов.

Пример разделения:
- Service — оркестрация логики  
- Repository — работа с БД  
- Client — внешний API  
- Adapter — Minio/файлы  

---

### O — Open / Closed

- Новый функционал добавляется через новые модули/классы, а не через хаки в существующих.

- Предпочитай:
- стратегии,
- фабрики,
- полиморфизм  
вместо длинных `if/else`.

---

### L — Liskov Substitution

- Реализации интерфейсов должны быть взаимозаменяемыми.

Если есть:

```python
class UserRepository(Protocol):
  def get(self, user_id: int) -> User: ...
````

То любая реализация должна вести себя предсказуемо:

* одинаковые типы,
* одинаковые гарантии,
* одинаковые исключения.

---

### I — Interface Segregation

* Не делай «больших универсальных интерфейсов».

Плохо:

```python
class MegaRepository:
    def get_user(...)
    def get_order(...)
    def upload_file(...)
```

Хорошо:

```python
UserRepository
OrderRepository
FileStorage
```

---

### D — Dependency Inversion

* Application-слой зависит только от абстракций.

Пример:

```python
class BookingService:
    def __init__(self, repo: BookingRepository):
        self.repo = repo
```

а не:

```python
class BookingService:
    def __init__(self):
        self.repo = SqlAlchemyBookingRepository()
```

---

# Правила по слоям

## FastAPI

* Роуты должны быть «тонкими»:

  * валидация,
  * DI,
  * маппинг DTO,
  * вызов сервиса,
  * возврат результата.

* Pydantic-схемы разделяй:

  * `CreateBookingRequest`
  * `BookingResponse`

* Не передавай SQLAlchemy-сессию глубоко в код:

  * только через явный слой репозитория.

* Не клади бизнес-логику в роутеры.

---

## aiogram

* Хендлеры — максимально тонкие:

  * парсинг апдейта,
  * вызов сервиса,
  * формирование ответа.

* FSM:

  * хранит только минимум данных для следующего шага,
  * не должен быть «кэшем всего контекста мира».

* Любая логика кроме простого диалога → в application-сервисы.

---

## Application / Service слой

* Сервисы:

  * не знают про HTTP, Telegram, FastAPI, aiogram;
  * работают только с абстракциями.

* Один сервис = один бизнес-сценарий.

* Сервисы:

  * принимают DTO,
  * возвращают DTO или доменные объекты,
  * не возвращают ORM-модели.

---

## Domain

* Если используем domain-слой:

  * в нём только правила и модели предметной области,
  * никакого SQLAlchemy, HTTP, Minio и т.д.

* Доменные исключения описываются здесь.

---

## Infrastructure

* Вся работа с внешним миром только здесь:

  * БД,
  * Minio,
  * сторонние API.

* Каждая интеграция закрыта интерфейсом.

Пример:

```
application → FileStorage (Protocol)
infrastructure → MinioFileStorage (implementation)
```

---

## SQLAlchemy / Alembic

* Все изменения схемы — только через миграции.

* Миграции должны быть:

  * читаемыми,
  * с понятным неймингом,
  * с явными индексами, nullable, unique.

* ORM-модели:

  * не используются как DTO,
  * не передаются в transport-слой.

---

## Minio

* Ключи объектов:

  * детерминированные,
  * структурированные по сущности/дате.

* Все операции хранения:

  * обёрнуты в отдельный адаптер/клиент,
  * легко мокируются в тестах.

---

# Тестируемость

* Код должен быть написан так, чтобы его было легко тестировать.

Обязательно:

* зависимости передаются через конструкторы;
* бизнес-логика тестируется без FastAPI и aiogram;
* инфраструктура мокается через интерфейсы.

---

# Антипаттерны (не допускаются)

* Бизнес-логика в роутерах и хендлерах.
* Передача ORM-моделей в ответы API.
* Прямые импорты инфраструктуры в application-слое.
* Глобальные синглтоны и скрытые зависимости.
* «Божественные» сервисы с десятками методов.
* Неформализованные dict вместо DTO.
